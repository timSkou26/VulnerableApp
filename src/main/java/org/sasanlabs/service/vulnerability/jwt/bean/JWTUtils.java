package org.sasanlabs.service.vulnerability.jwt.bean;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.io.IOUtils;
import org.sasanlabs.service.exception.ExceptionStatusCodeEnum;
import org.sasanlabs.service.exception.ServiceApplicationException;

/** @author KSASAN preetkaran20@gmail.com */
public class JWTUtils {

    // ------------------------------------------------------
    // ΔΙΟΡΘΩΣΗ: Private constructor (utility class)
    // ------------------------------------------------------
    private JWTUtils() {
        // Utility class – no instances allowed
    }

    public static final char JWT_TOKEN_PERIOD_CHARACTER = '.';

    public static final String JWT_TOKEN_PERIOD_CHARACTER_REGEX =
            "[" + JWT_TOKEN_PERIOD_CHARACTER + "]";

    public static final String BASE64_PADDING_CHARACTER_REGEX = "=";

    public static final String NONE_ALGORITHM = "none";
    public static final String JWT_ALGORITHM_KEY_HEADER = "alg";
    public static final String JSON_WEB_KEY_HEADER = "jwk";
    public static final String JWT_RSA_ALGORITHM_IDENTIFIER = "RS";
    public static final String JWT_RSA_PSS_ALGORITHM_IDENTIFIER = "PS";
    public static final String JWT_HMAC_ALGORITHM_IDENTIFIER = "HS";
    public static final String JWT_EC_ALGORITHM_IDENTIFIER = "EC";
    public static final String JWT_OCTET_ALGORITHM_IDENTIFIER = "ED";
    public static final String JWT_HMAC_SHA_256_ALGORITHM = "HS256";

    public static final String HS256_TOKEN_TO_BE_SIGNED =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
                    + "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ";

    public static final String RS256_TOKEN_TO_BE_SIGNED =
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9."
                    + "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0";

    public static final String GENERIC_BASE64_ENCODED_PAYLOAD =
            "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG"
                    + "4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0";

    public static final String KEYS_LOCATION = "static/templates/JWTVulnerability/keys/";

    public static final String BEGIN_PRIVATE_KEY_TOKEN = "-----BEGIN PRIVATE KEY-----";
    public static final String END_PRIVATE_KEY_TOKEN = "-----END PRIVATE KEY-----";
    public static final String BEGIN_PUBLIC_KEY_TOKEN = "-----BEGIN PUBLIC KEY-----";
    public static final String END_PUBLIC_KEY_TOKEN = "-----END PUBLIC KEY-----";

    public static byte[] getBytes(String token) throws UnsupportedEncodingException {
        return token.getBytes(StandardCharsets.UTF_8);
    }

    public static String getString(byte[] tokenBytes) throws UnsupportedEncodingException {
        return new String(tokenBytes, StandardCharsets.UTF_8);
    }

    // ------------------------------------------------------
    // ΔΙΟΡΘΩΣΗ: visibility → protected (Sonar suggestion)
    // ------------------------------------------------------
    protected static final Map<String, String> JWT_HMAC_ALGO_TO_JAVA_ALGORITHM_MAPPING =
            createJWTHmacAlgoToJavaAlgoMapping();

    static Map<String, String> createJWTHmacAlgoToJavaAlgoMapping() {
        Map<String, String> jwtAlgoToJavaAlgoMapping = new HashMap<>();
        jwtAlgoToJavaAlgoMapping.put(JWT_HMAC_SHA_256_ALGORITHM, "HmacSHA256");
        jwtAlgoToJavaAlgoMapping.put("HS384", "HmacSHA384");
        jwtAlgoToJavaAlgoMapping.put("HS512", "HmacSHA512");
        return jwtAlgoToJavaAlgoMapping;
    }

    // ------------------------------------------------------
    // ΠΑΛΙΟΣ ΚΩΔΙΚΑΣ (Code Smell – if/else)
    // ------------------------------------------------------
    /*
    private static boolean containsSection(String contents, String beginToken, String endToken) {
        int idxToken;
        if ((idxToken = contents.indexOf(beginToken)) == -1
                || contents.indexOf(endToken) < idxToken) {
            return false;
        }
        return true;
    }
    */

    // ------------------------------------------------------
    // ΝΕΟΣ – ΔΙΟΡΘΩΜΕΝΟΣ ΚΩΔΙΚΑΣ
    // Single return statement
    // Πιο καθαρός, λιγότερη γνωστική πολυπλοκότητα
    // ------------------------------------------------------
    private static boolean containsSection(String contents, String beginToken, String endToken) {
        int idxToken = contents.indexOf(beginToken);
        return idxToken != -1 && contents.indexOf(endToken) > idxToken;
    }

    private static byte[] parseDERFromPEM(String pem, String beginDelimiter, String endDelimiter) {
        if (!containsSection(pem, beginDelimiter, endDelimiter)) {
            return new byte[0];
        }
        String[] tokens = pem.split(beginDelimiter);
        tokens = tokens[1].split(endDelimiter);
        return Base64.getMimeDecoder().decode(tokens[0]);
    }

    public static RSAPrivateKey getRSAPrivateKeyFromProvidedPEMFilePath(InputStream pemFile)
            throws ServiceApplicationException {
        try {
            String certAndKey = IOUtils.toString(pemFile, StandardCharsets.US_ASCII);
            byte[] keyBytes =
                    parseDERFromPEM(certAndKey, BEGIN_PRIVATE_KEY_TOKEN, END_PRIVATE_KEY_TOKEN);
            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory factory = KeyFactory.getInstance("RSA");
            return (RSAPrivateKey) factory.generatePrivate(spec);
        } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new ServiceApplicationException(ExceptionStatusCodeEnum.SYSTEM_ERROR, e);
        }
    }

    public static RSAPublicKey getRSAPublicKeyFromProvidedPEMFilePath(InputStream pemFile)
            throws ServiceApplicationException {
        try {
            String certAndKey = IOUtils.toString(pemFile, StandardCharsets.US_ASCII);
            byte[] keyBytes =
                    parseDERFromPEM(certAndKey, BEGIN_PUBLIC_KEY_TOKEN, END_PUBLIC_KEY_TOKEN);
            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
            KeyFactory factory = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) factory.generatePublic(spec);
        } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new ServiceApplicationException(ExceptionStatusCodeEnum.SYSTEM_ERROR, e);
        }
    }
}
