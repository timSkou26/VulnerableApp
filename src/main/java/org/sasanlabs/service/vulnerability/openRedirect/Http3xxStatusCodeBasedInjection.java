package org.sasanlabs.service.vulnerability.openRedirect;

import static org.sasanlabs.vulnerability.utils.Constants.NULL_BYTE_CHARACTER;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Function;

import org.sasanlabs.internal.utility.FrameworkConstants;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.vulnerability.types.VulnerabilityType;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.RequestParam;

@VulnerableAppRestController(
        descriptionLabel = "OPEN_REDIRECTION_VULNERABILITY_3XX_BASED",
        value = "Http3xxStatusCodeBasedInjection")
public class Http3xxStatusCodeBasedInjection {

    private static final String LOCATION_HEADER_KEY = "Location";
    private static final String RETURN_TO = "returnTo";

    // Επιτρεπτές μόνο εσωτερικές σελίδες (whitelist)
    private static final Set<String> WHITELISTED_URLS =
            new HashSet<>(Arrays.asList("/", "/VulnerableApp/"));

    // ================================================================
    // ΑΣΦΑΛΗΣ VERSION της μεθόδου που κάνει redirect (REFACRORED)
    // ================================================================
    private ResponseEntity<?> getURLRedirectionResponseEntity(String urlToRedirect,
                                                              Function<String, Boolean> validator) {

        MultiValueMap<String, String> headerParam = new HttpHeaders();

        // -----------------------------------------------------------
        // ❌ ΠΡΟΒΛΗΜΑΤΙΚΟΣ ΚΩΔΙΚΑΣ (Open Redirect)
        // -----------------------------------------------------------
        /*
        if (validator.apply(urlToRedirect)) {
            headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
            headerParam.get(LOCATION_HEADER_KEY).add(urlToRedirect); // UNSAFE !!!
            return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
        }
        */
        // Αιτία προβλήματος: Το user-controlled URL βγαίνει κατευθείαν στο Location header.


        // -----------------------------------------------------------
        // ✅ ΑΣΦΑΛΗΣ ΥΛΟΠΟΙΗΣΗ (Whitelist + No external URLs)
        // -----------------------------------------------------------
        if (validator.apply(urlToRedirect)) {

            // Μπλοκάρισμα εξωτερικών URLs
            if (urlToRedirect.startsWith("http://") ||
                urlToRedirect.startsWith("https://") ||
                urlToRedirect.startsWith("//")) {

                return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
            }

            // Ελέγχουμε αν υπάρχει ακριβής whitelist match
            if (!WHITELISTED_URLS.contains(urlToRedirect)) {
                return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
            }

            // SAFE REDIRECT
            headerParam.put(LOCATION_HEADER_KEY, new ArrayList<>());
            headerParam.get(LOCATION_HEADER_KEY).add(urlToRedirect);

            return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
        }

        return new ResponseEntity<>(HttpStatus.OK);
    }


    /** LEVEL 1 */
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.OPEN_REDIRECT_3XX_STATUS_CODE},
            description = "OPEN_REDIRECT_QUERY_PARAM_DIRECTLY_ADD_TO_LOCATION_HEADER")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/Http3xxStatusCodeBasedInjection")
    public ResponseEntity<?> getVulnerablePayloadLevel1(
            @RequestParam(RETURN_TO) String urlToRedirect) {

        // Το validator επιτρέπει τα πάντα — αλλά ο SINK είναι τώρα ασφαλής
        return this.getURLRedirectionResponseEntity(urlToRedirect, (url) -> true);
    }


    // LEVEL 2
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.OPEN_REDIRECT_3XX_STATUS_CODE},
            description =
                    "OPEN_REDIRECT_QUERY_PARAM_DIRECTLY_ADD_TO_LOCATION_HEADER_IF_NOT_HTTP_HTTPS_WWW_OR_DOMAIN_IS_SAME")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_1/Http3xxStatusCodeBasedInjection")
    public ResponseEntity<?> getVulnerablePayloadLevel2(
            RequestEntity<String> requestEntity, @RequestParam(RETURN_TO) String urlToRedirect)
            throws MalformedURLException {

        URL requestUrl = new URL(requestEntity.getUrl().toString());

        return this.getURLRedirectionResponseEntity(
                urlToRedirect,
                (url) ->
                        (!url.startsWith(FrameworkConstants.HTTP)
                                && !url.startsWith(FrameworkConstants.HTTPS)
                                && !url.startsWith(FrameworkConstants.WWW))
                                || requestUrl.getAuthority().equals(urlToRedirect));
    }


    // LEVEL 3
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.OPEN_REDIRECT_3XX_STATUS_CODE},
            description =
                    "OPEN_REDIRECT_QUERY_PARAM_DIRECTLY_ADD_TO_LOCATION_HEADER_IF_NOT_HTTP_HTTPS_WWW_//_OR_DOMAIN_IS_SAME")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_1/Http3xxStatusCodeBasedInjection")
    public ResponseEntity<?> getVulnerablePayloadLevel3(
            RequestEntity<String> requestEntity, @RequestParam(RETURN_TO) String urlToRedirect)
            throws MalformedURLException {

        URL requestUrl = new URL(requestEntity.getUrl().toString());

        return this.getURLRedirectionResponseEntity(
                urlToRedirect,
                (url) ->
                        (!url.startsWith(FrameworkConstants.HTTP)
                                && !url.startsWith(FrameworkConstants.HTTPS)
                                && !url.startsWith("//")
                                && !url.startsWith(FrameworkConstants.WWW))
                                || requestUrl.getAuthority().equals(url));
    }


    // LEVEL 4
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.OPEN_REDIRECT_3XX_STATUS_CODE},
            description =
                    "OPEN_REDIRECT_QUERY_PARAM_DIRECTLY_ADD_TO_LOCATION_HEADER_IF_NOT_HTTP_WWW_HTTPS_//_NULL_BYTE_OR_DOMAIN_IS_SAME")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_1/Http3xxStatusCodeBasedInjection")
    public ResponseEntity<?> getVulnerablePayloadLevel4(
            RequestEntity<String> requestEntity, @RequestParam(RETURN_TO) String urlToRedirect)
            throws MalformedURLException {

        URL requestUrl = new URL(requestEntity.getUrl().toString());

        return this.getURLRedirectionResponseEntity(
                urlToRedirect,
                (url) ->
                        (!url.startsWith(FrameworkConstants.HTTP)
                                && !url.startsWith(FrameworkConstants.HTTPS)
                                && !url.startsWith(FrameworkConstants.WWW)
                                && !url.startsWith("//")
                                && !url.startsWith(NULL_BYTE_CHARACTER))
                                || requestUrl.getAuthority().equals(url));
    }


    // LEVEL 5
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.OPEN_REDIRECT_3XX_STATUS_CODE},
            description =
                    "OPEN_REDIRECT_QUERY_PARAM_DIRECTLY_ADD_TO_LOCATION_HEADER_IF_NOT_HTTP_HTTPS_//_WWW_%_OR_DOMAIN_IS_SAME")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            htmlTemplate = "LEVEL_1/Http3xxStatusCodeBasedInjection")
    public ResponseEntity<?> getVulnerablePayloadLevel5(
            RequestEntity<String> requestEntity, @RequestParam(RETURN_TO) String urlToRedirect)
            throws MalformedURLException {

        URL requestUrl = new URL(requestEntity.getUrl().toString());

        return this.getURLRedirectionResponseEntity(
                urlToRedirect,
                (url) ->
                        (!url.startsWith(FrameworkConstants.HTTP)
                                && !url.startsWith(FrameworkConstants.HTTPS)
                                && !url.startsWith("//")
                                && !url.startsWith(FrameworkConstants.WWW)
                                && !url.startsWith(NULL_BYTE_CHARACTER)
                                && (url.length() > 0 && url.charAt(0) > 20))
                                || requestUrl.getAuthority().equals(url));
    }


    // LEVEL 6 (το συγκεκριμένο που σου έκανε SonarQube error)
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.OPEN_REDIRECT_3XX_STATUS_CODE},
            description =
                    "OPEN_REDIRECT_QUERY_PARAM_DIRECTLY_ADDED_TO_LOCATION_HEADER_BY_ADDING_DOMAIN_AS_PREFIX")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            htmlTemplate = "LEVEL_1/Http3xxStatusCodeBasedInjection")
    public ResponseEntity<?> getVulnerablePayloadLevel6(
            RequestEntity<String> requestEntity, @RequestParam(RETURN_TO) String urlToRedirect)
            throws MalformedURLException {

        // ❌ ΠΡΟΒΛΗΜΑΤΙΚΟΣ ΚΩΔΙΚΑΣ:
        /*
        headerParam
                .get(LOCATION_HEADER_KEY)
                .add(requestUrl.getProtocol() + "://" + requestUrl.getAuthority() + urlToRedirect);
        return new ResponseEntity<>(headerParam, HttpStatus.FOUND);
        */

        // Χρησιμοποιούμε τώρα το ασφαλές wrapper:
        return this.getURLRedirectionResponseEntity(urlToRedirect, (url) -> true);
    }


    // LEVEL 7
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.OPEN_REDIRECT_3XX_STATUS_CODE},
            description =
                    "OPEN_REDIRECT_QUERY_PARAM_DIRECTLY_ADDED_TO_LOCATION_HEADER_BY_ADDING_DOMAIN_AS_PREFIX")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_7,
            htmlTemplate = "LEVEL_1/Http3xxStatusCodeBasedInjection")
    public ResponseEntity<?> getVulnerablePayloadLevel7(
            RequestEntity<String> requestEntity, @RequestParam(RETURN_TO) String urlToRedirect)
            throws MalformedURLException {

        return this.getURLRedirectionResponseEntity(urlToRedirect, (url) -> true);
    }


    // LEVEL 8 (ήταν ήδη whitelist-based)
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_8,
            htmlTemplate = "LEVEL_1/Http3xxStatusCodeBasedInjection")
    public ResponseEntity<?> getVulnerablePayloadLevel8(
            RequestEntity<String> requestEntity, @RequestParam(RETURN_TO) String urlToRedirect) {

        return this.getURLRedirectionResponseEntity(urlToRedirect, WHITELISTED_URLS::contains);
    }
}
